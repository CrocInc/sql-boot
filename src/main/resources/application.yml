templateAggregator: |
  <databaseChangeLog
      xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:ext="http://www.liquibase.org/xml/ns/dbchangelog-ext"
      xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd
      http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd">

      <preConditions>
          <runningAs username="liquibase"/>
      </preConditions>

      <% objects.each {%>$it.ddl<%}%>

  </databaseChangeLog>

---
spring:
  profiles: information_schema

schemas: |
  select s.schema_name as "schema"
    from information_schema.schemata s
   where lower(s.schema_name) like '$schema'

tables: |
  select * from (
    select t.table_schema       as "schema"
         , t.table_name         as "table"
         , t.remarks            as "@comment"
         , t.last_modification  as "@last_date"
         , t.table_type         as "@table_type"
         -- TODO move file_name construction to file aggregator ?
         , t.table_schema || '/tables/' || t.table_name || '/main.sql' as "@file_name"
      from information_schema.tables t
     where lower(t.table_schema) like '$schema'
       and lower(t.table_name) like '$table'
       and lower(t.table_name) not like '%_materialized'
     order by t.table_name)

table.sql.create: |
  create table "$schema"."$table.name" (<%srv.get('column').each {%>
    !{it.name.padRight(20)}!{it.properties.data_type.toLowerCase()}!{it.properties.length}<%if (it != srv.get('column').last()){%>,<%}}%>
  );

table.sql.drop: |
  drop table $schema.$table.name;

table.info: |
  columns=srv.get('column')
  table(border:'1'){
    caption('"'+schema+'"."'+table.name+'"')
    tr{th('COLUMN')th('TYPE')th('SIZE')}
    columns.each{
      column=it
      tr{td(column.name)td(column.properties.data_type)td(column.properties.length)}
    }
  }

table.migrate.create: |
  columns=srv.get('column')
  changeSet(id:'1', author:'supper_user'){
    createTable(schemaName:schema, tableName:table.name, remarks:table.properties.comment){
      columns.each{column(name:it.name, type:it.properties.data_type.toLowerCase()+it.properties.length)}
    }
  }

table.migrate.drop: |
  columns=srv.get('column')
  changeSet(id:'1', author:'supper_user'){
    dropTable(schemaName:schema, tableName:table.name)
  }

table.columns: |
  select * from (
    select c.table_schema   as "schema"
         , c.table_name     as "table"
         , c.column_name    as "column"
         , c.type_name      as "@data_type"
         , case when c.type_name like 'VARCHAR%' then '('|| c.character_maximum_length ||')' end as "@length"
         , c.nullable       as "@nullable"
         , c.column_default as "@column_default"
    from information_schema.columns c
   where lower(c.table_schema) like '$schema'
     and lower(c.table_name) like '$table'
     and lower(c.column_name) like '$column'
   order by c.ordinal_position asc)


table.column.sql.create: |
  alter table $table add column $column.name;

table.column.sql.drop: |
  alter table $table drop $column.name;


table.pk: |
  select * from (
    select c.table_schema as "schema"
         , c.table_name as "table"
         , c.constraint_name as "pk"
         , c.table_schema || '/tables/' || c.table_name || '/pk.sql' as "@file_name"
         , c.sql as "@sql"
      from information_schema.constraints c
     where constraint_type  = 'PRIMARY KEY'
       and lower(table_schema) like '$schema'
       and lower(table_name) like '$table'
       and lower(constraint_name) like '$pk')

table.pk.sql.create: |
  !{pk.properties.sql};

table.pk.sql.drop: |
  alter table $table drop pk $pk.name;


table.fk: |
  select * from (
    select c.table_schema as "schema"
         , c.table_name as "table"
         , c.constraint_name as "fk"
         , c.table_schema || '/tables/' || c.table_name || '/foreign_keys/' || c.constraint_name || '.sql' as "@file_name"
         , c.sql as "@sql"
      from information_schema.constraints c
     where constraint_type  = 'REFERENTIAL'
       and lower(table_schema) like '$schema'
       and lower(table_name) like '$table'
       and lower(constraint_name) like '$pk')

table.fk.sql.create: |
  !{fk.properties.sql};

table.fk.sql.drop: |
  alter table $table drop constraint $fk.name;



table.indexes: |
  select * from (
    select c.table_schema as "schema"
         , c.table_name as "table"
         , c.index_name as "index"
         , c.table_schema || '/tables/' || c.table_name || '/indexes/' || c.index_name || '.sql' as "@file_name"
         , c.sql as "@sql"
      from information_schema.indexes c
     where index_type_name <> 'PRIMARY KEY'
       and lower(table_schema) like '$schema'
       and lower(table_name) like '$table'
       and lower(index_name) like '$index')

table.index.sql.create: |
  !{index.properties.sql};

table.index.sql.drop: |
  drop index $index.name;


table.checks: |
  select * from (
    select c.table_schema as "schema"
         , c.table_name as "table"
         , c.constraint_name as "check"
         , c.table_schema || '/tables/' || c.table_name || '/indexes/' || c.constraint_name || '.sql' as "@file_name"
         , c.sql as "@sql"
      from information_schema.constraints c
     where constraint_type = 'CHECK'
       and lower(table_schema) like '$schema'
       and lower(table_name) like '$table'
       and lower(constraint_name) like '$check')

table.check.sql.create: |
  !{check.properties.sql};

table.check.sql.drop: |
  drop check $check.name;


views: |
  select * from (
    select t.table_schema   as "schema"
         , t.table_name     as "view"
         , t.view_definition as "@sql"
         , t.table_schema || '/views/' || t.table_name || '.sql' as "@file_name"
      from information_schema.views t
     where lower(t.table_schema) like '$schema'
       and lower(t.table_name) like '$table'
     order by t.table_name)

view.sql.create: |
  !{view.properties.sql};

view.sql.drop: |
  drop view $view.name;


mviews: |
  select * from (
    select t.table_schema   as "schema"
         , t.table_name     as "view"
         , t.view_definition as "@sql"
         , t.table_schema || '/views/' || t.table_name || '.sql' as "@file_name"
      from information_schema.views t
     where lower(t.table_schema) like '$schema'
       and lower(t.table_name) like '$table'
       and lower(t.table_name) like '%_materialized'
     order by t.table_name)

mview.sql.create: |
  create table "$schema"."$mview.name" (<%srv.get('column').each {%>
    !{it.name.padRight(20)}!{it.properties.data_type.toLowerCase()}!{it.properties.length}<%if (it != srv.get('column').last()){%>,<%}}%>
  );

mview.sql.drop: |
  drop table $mview.name;


---
spring:
  profiles: postgres

tables: |
  select t.table_schema     as "schema"
       , t.table_name       as "table"
    from information_schema.tables t
   where t.table_type='BASE TABLE'
     and lower(t.table_schema) like '$schema'
     and lower(t.table_name) like '$table'

table.sql.create: |
  create table "$schema".$table.name" ...;

table.drop: |
  drop table $schema.$table;

table.columns: |
  select c.table_schema     as "schema"
       , c.table_name       as "table"
       , c.column_name      as "column"
       , c.udt_name         as "@data_type"
       , case when c.udt_name like 'varchar%' then '('|| c.character_maximum_length ||')' end as "@length"
       , c.is_nullable      as "@is_nullable"
       , c.column_default   as "@column_default"
    from information_schema.columns c
        ,information_schema.tables t
   where t.table_schema = c.table_schema
     and t.table_name = c.table_name
     and t.table_type='BASE TABLE'
     and lower(c.table_schema) like '$schema'
     and lower(c.table_name) like '$table'
     and lower(c.column_name) like '$column'
   order by c.ordinal_position asc